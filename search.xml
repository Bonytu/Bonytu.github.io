<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[康复训练·舞蹈链]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83%C2%B7%E8%88%9E%E8%B9%88%E9%93%BE%2F</url>
    <content type="text"><![CDATA[dance link，针对精确覆盖问题和完全覆盖问题的优化，本质上优化的是搜索时回溯储存恢复的代价。 精确覆盖和完全覆盖只是回溯时的条件不同，此处仅针对精确覆盖问题。 精确覆盖问题描述给定01矩阵$A$，试选取若干行构成一个新矩阵$B$，使得$B$中每列恰好只有一个1。 思路回溯储存恢复主要依靠链表的del和resv操作，不难想象，当a、b、c、d依次删除时，d、c、b、a依次恢复结果是正确的，和dfs的栈顺序是对应的。 123456void Delete(Linklist *i)&#123; i-&gt;prev-&gt;next=i-&gt;r,i-&gt;next-&gt;prev=i-&gt;prev;&#125;void Resume(Linklist* i)&#123; i-&gt;prev-&gt;next=i-&gt;next-&gt;prev=i;&#125; 基本思路就是dfs的暴力搜索，对于每一个要覆盖的列，枚举覆盖它使用的行即可。 删除和恢复的原子操作都是以列进行的，即当前列直接关联的行。 每次要删除当前列以及与枚举的行关联的列。 代码http://hihocoder.com/problemset/problem/1317 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;using namespace std;namespace LINKLIST&#123; const int maxNum=1e4+10; struct linkList&#123; linkList* l,*r,*u,*d; int cols;//列 int rows;//行 &#125;pool[maxNum]; int inc; #define NewMemory() (&amp;pool[inc++]) enum Direct&#123;up,down,left,right&#125;; void append(linkList *i, linkList *j, Direct direct)&#123; switch (direct)&#123; case up:&#123; j-&gt;u=i-&gt;u,i-&gt;u-&gt;d=j; i-&gt;u=j,j-&gt;d=i; break; &#125; case down:&#123; j-&gt;d=i-&gt;d,i-&gt;d-&gt;u=j; i-&gt;d=j,j-&gt;u=i; break; &#125; case left:&#123; j-&gt;l=i-&gt;l,i-&gt;l-&gt;r=j; i-&gt;l=j,j-&gt;r=i; break; &#125; case right:&#123; j-&gt;r=i-&gt;r,i-&gt;r-&gt;l=j; i-&gt;r=j,j-&gt;l=i; &#125; &#125; &#125; void delCol(linkList* *a,int m_cols)&#123;//删除列，删除列中为1的所有行 a[m_cols]-&gt;r-&gt;l=a[m_cols]-&gt;l, a[m_cols]-&gt;l-&gt;r=a[m_cols]-&gt;r;//删除列，删除列头就可以保证不被访问 for (linkList *q=a[m_cols]-&gt;d;q!=a[m_cols];q=q-&gt;d) for (linkList* p=q-&gt;r;p!=q;p=p-&gt;r) p-&gt;u-&gt;d=p-&gt;d,p-&gt;d-&gt;u=p-&gt;u;//删除行，需要删除其他列中改行的元素 &#125; void resCol(linkList* *a,int m_cols)&#123; a[m_cols]-&gt;r-&gt;l=a[m_cols]-&gt;l-&gt;r=a[m_cols];//恢复列 for (linkList *q=a[m_cols]-&gt;d;q!=a[m_cols];q=q-&gt;d) for (linkList* p=q-&gt;r;p!=q;p=p-&gt;r) p-&gt;u-&gt;d=p-&gt;d-&gt;u=p;//恢复行，需要恢复其他列中改行的元素 &#125;&#125;using namespace LINKLIST;const int max_n=110,max_m=110;linkList* a[max_m],*b[max_n];bool flag=false;void dfs()&#123; if (flag==true) return ; if (a[0]-&gt;r==a[0])&#123; flag=true; return ; &#125; linkList *next=a[0]-&gt;r; if (next-&gt;d==next) return ;//代表a[0]-&gt;r这条件无法满足 delCol(a,next-&gt;cols); for (linkList *q=next-&gt;d;q!=next;q=q-&gt;d)&#123;//枚举行 for (linkList *p=q-&gt;r;p!=q;p=p-&gt;r) delCol(a,p-&gt;cols);//删除行对应的列 dfs(); for (linkList *p=q-&gt;r;p!=q;p=p-&gt;r) resCol(a,p-&gt;cols); &#125; resCol(a,next-&gt;cols);&#125;void sol()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; inc=0; for (int q=0;q&lt;=n;++q) b[q]=NULL; a[0]=NewMemory(); for (int q=1;q&lt;=m;++q)&#123; a[q]=NewMemory(); a[q]-&gt;l=a[q-1],a[q-1]-&gt;r=a[q]; a[q]-&gt;u=a[q]-&gt;d=a[q]; a[q]-&gt;cols=q; &#125; a[0]-&gt;l=a[m],a[m]-&gt;r=a[0]; for (int q=1,ch;q&lt;=n;++q)&#123; for (int p=1;p&lt;=m;++p)&#123; cin&gt;&gt;ch; if (ch)&#123; linkList* i=NewMemory(); i-&gt;cols=p; append(a[p],i,LINKLIST::up); if (b[q]==NULL)&#123; b[q]=i; b[q]-&gt;l=b[q]-&gt;r=b[q]; &#125; else &#123; append(b[q],i,LINKLIST::right); b[q]=i; &#125; &#125; &#125; &#125; flag=false; dfs(); cout&lt;&lt;(flag?"Yes":"No")&lt;&lt;endl;&#125;int main()&#123; cin.sync_with_stdio(false); cout.sync_with_stdio(false); int t; cin&gt;&gt;t; while (t--)&#123; sol(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>dance link</tag>
        <tag>搜索</tag>
        <tag>双向十字循环链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[康复训练·后缀自动机]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83%C2%B7%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[后缀自动机 (suffix automaton SAM)，有穷状态自动机(deterministic finite automaton,DFA)的一种。 构造1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const int max_n=1e6+10;const int char_size=26;//字符集合大小int slink[2*max_n+10];int tran[2*max_n+10][char_size];int max_len[2*max_n+10],min_len[2*max_n+10];int sam_len=0;int new_state(int _max_len,int _min_len,int *_tran,int _slink)&#123; slink[sam_len]=_slink; if (_tran==NULL) for (int q=0;q&lt;char_size;++q) tran[sam_len][q]=-1; else for (int q=0;q&lt;char_size;++q) tran[sam_len][q]=_tran[q]; max_len[sam_len]=_max_len,min_len[sam_len]=_min_len; return sam_len++;&#125;int add_char(char i,int _now)&#123; int _next=new_state(max_len[_now]+1,0,NULL,-1); int c=i-'a'; while (_now!=-1 &amp;&amp; tran[_now][c]==-1)&#123; tran[_now][c]=_next; _now=slink[_now]; &#125; if (_now==-1)&#123; slink[_next]=0,min_len[_next]=1; return _next; &#125; else &#123; int p= tran[_now][c]; if (max_len[p]==max_len[_now]+1)&#123; min_len[_next]=max_len[p]+1; slink[_next]=p; return _next; &#125; else &#123; int _temp=new_state(max_len[_now]+1,min_len[_now]+1,tran[p],slink[p]); slink[p]=_temp,min_len[p]=max_len[_temp]+1; slink[_next]=_temp,min_len[_next]=max_len[_temp]+1; min_len[_temp]=max_len[slink[_temp]]+1; while (_now!=-1 &amp;&amp; tran[_now][c]==p)&#123; tran[_now][c]=_temp; _now=slink[_now]; &#125; return _next; &#125; &#125;&#125;void SAM(char *s)&#123; sam_len=0; int now=new_state(0,0,NULL,-1); int str_len=strlen(s); for (int q=0;q&lt;str_len;++q)&#123; now=add_char(s[q],now); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Suffix Automaton</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数月来]]></title>
    <url>%2F2019%2F01%2F31%2F%E6%95%B0%E6%9C%88%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[过去的半年发生了很多（对我来说的）大事，姑且用我最擅长的流水账记录一下。 TimeLine 2018.1，ACM半退役，在前队友wzh的引荐下，开始到航院高云龙老师那里搞维数约减/聚类。 2018.3，面对爆炸的GPA&amp;&amp;过不了的六级，开始想找工作。陆续大概投了网易、百度、商汤、头条、旷视、长亭、微软等，岗位基本是算法工程师/研究员之类的，结果： 网易：随手报的岗位大数据，发现考Hadoop，GG 微软：机试特别水的三道题，最难的应该是一道中途相遇背包。大概因为投的北京，简历被筛了；若是苏州或许能过。 头条、百度，内推完没人理我。 2018.5，由于工作找不到，还被whuang老师D了一通，开始试试能不能读研。抢救英语，报了雅思*3，实习攒的钱散光了；同时开始准备报夏令营，大概投了软件所、计算所、自动化所、上交计算机、南大人工智能、浙大计算机、人大计算机、清华软件、北航计算机。 2018.6，雅思成绩5.5*2，第3次在8月；收到旷视、商汤、长亭面试并获得offer；夏令营通过人大、计算所、北航；开始准备投二区的论文。一些细节： 关于实习： 三所公司的面试都是在线文档+问简历+算法题的模式，还算友好。 旷视似乎很喜欢出矩阵来回走的题目；商汤题目忘了；长亭最难的貌似是线段树+lazy。 最后在工资的诱惑下去了旷视。 关于夏令营： 北航时间冲突，放弃；计算所自行联系老师，方向不喜欢，放弃； 人大提前联系老师，现场发生了一些奇怪的事情，感觉机试面试设置略显敷衍，未获得保研资格。 上交联系到了对应老师，然而GPA指标被招生办卡住，未获得夏令营资格，但因此认识了可爱的女票张笨笨同学。 2018.8，雅思5.5*3，六级通过；前往北京入职旷视；开始准备九推，投了软件所、计算所、自动化所、信工所、上交计算机、南大人工智能、浙大计算机、清华软件、清华深圳、北大信工、北大软微、复旦计算机，国科大计算机学院。 2018.9，艰难的实习入门、九推、脱团。 复旦计算机获得学硕资格，英语面试+机试+面试，机试水题、单调栈、中途相遇，大约半小时的量。 清华软件获得工硕资格，机试+面试，机试水题、快速幂、简单dp，大约半小时的量；面试非常友好，比如问我如果被调剂为工硕，还过了浙大学硕选哪个…..事实上当天下午我就收到了浙大初审不通过的消息。 北大信工面试前有个老师联系我，给学硕，方向cv。 国科大面试前有个老师联系我，方向nlp。 系统确认前有个软件所老师联系我，方向忘了（软件所看起来被咕咕咕得好惨哇）。 因为投的时间太迟，清华深圳和北大软微没寄到。 信工所冲突，放弃。 剩下的没通过。 2018.10，专心搬砖，半数清华的MEGVII，解决问题以秒计的恩哥，代码洁癖的LZH等等，学到了很多。 Summary感谢高老师、whuang、wzh、wdx、wnx、gw，抱抱张笨笨同学。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>保研</tag>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
