<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[win 10内置linux配置备份]]></title>
    <url>%2F2019%2F03%2F11%2Fwindows%E5%86%85%E7%BD%AElinux%E9%85%8D%E7%BD%AE%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[内置Linux炸了一次，保留一份备份。 zsh安装： 12sudo apt install zshsh -c "$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" 在~/.bashrc添加exec zsh source ~/.bashrc vim配置: 1234git clone --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtimesh ~/.vim_runtime/install_awesome_vimrc.shcurl -fLo ~/.vim_runtime/autoload/plug.vim --create-dirs \https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vimln -s ~/.vim_runtime/my_configs.vim ~/.myvimrc .myvimrc: 12345678910111213141516171819202122" File : my_configs.vim" Author : Your Name &lt;your@mail&gt;" Date : 22.02.2019" Last Modified Date: 22.02.2019" Last Modified By : Your Name &lt;your@mail&gt;set numbercall plug#begin('~/.vim_runtime/plugged')Plug 'chxuan/cpp-mode'Plug 'Chiel92/vim-autoformat'Plug 'alpertuna/vim-header'Plug 'Valloric/YouCompleteMe'call plug#end()"add header info"let g:header_field_author = 'wushengsen'let g:header_field_author_email = 'peanut-wu@foxmail.com'let g:header_auto_add_header = 0let g:header_field_copyright = ''map &lt;F4&gt; :AddHeader&lt;CR&gt;"ycm" let g:ycm_global_ycm_extra_conf='~/.vim_runtime/plugged/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py']]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>linux配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[康复训练·舞蹈链]]></title>
    <url>%2F2019%2F02%2F22%2F%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83%C2%B7%E8%88%9E%E8%B9%88%E9%93%BE%2F</url>
    <content type="text"><![CDATA[dance link，针对精确覆盖问题和完全覆盖问题的优化，本质上优化的是搜索时回溯储存恢复的代价。 精确覆盖和完全覆盖只是回溯时的条件不同，此处仅针对精确覆盖问题。 精确覆盖问题描述给定01矩阵$A$，试选取若干行构成一个新矩阵$B$，使得$B$中每列恰好只有一个1。 思路回溯储存恢复主要依靠链表的del和resv操作，不难想象，当a、b、c、d依次删除时，d、c、b、a依次恢复结果是正确的，和dfs的栈顺序是对应的。 123456void Delete(Linklist *i)&#123; i-&gt;prev-&gt;next=i-&gt;r,i-&gt;next-&gt;prev=i-&gt;prev;&#125;void Resume(Linklist* i)&#123; i-&gt;prev-&gt;next=i-&gt;next-&gt;prev=i;&#125; 基本思路就是dfs的暴力搜索，对于每一个要覆盖的列，枚举覆盖它使用的行即可。 删除和恢复的原子操作都是以列进行的，即当前列直接关联的行。 每次要删除当前列以及与枚举的行关联的列。 代码#1317 : 搜索四·跳舞链123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * File : dancelink.cpp * Author : wushengsen &lt;peanut-wu@foxmail.com&gt; * Date : 22.02.2019 * Last Modified Date: 22.02.2019 * Last Modified By : wushengsen &lt;peanut-wu@foxmail.com&gt; */#include&lt;bits/stdc++.h&gt;using namespace std;namespace LINKLIST&#123; const int maxNum=1e4+10; struct linkList&#123; linkList* l,*r,*u,*d; int cols;//列 int rows;//行 &#125;pool[maxNum]; int inc;#define NewMemory() (&amp;pool[inc++]) enum Direct&#123;up,down,left,right&#125;; void append(linkList *i, linkList *j, Direct direct)&#123; switch (direct)&#123; case up:&#123; j-&gt;u=i-&gt;u,i-&gt;u-&gt;d=j; i-&gt;u=j,j-&gt;d=i; break; &#125; case down:&#123; j-&gt;d=i-&gt;d,i-&gt;d-&gt;u=j; i-&gt;d=j,j-&gt;u=i; break; &#125; case left:&#123; j-&gt;l=i-&gt;l,i-&gt;l-&gt;r=j; i-&gt;l=j,j-&gt;r=i; break; &#125; case right:&#123; j-&gt;r=i-&gt;r,i-&gt;r-&gt;l=j; i-&gt;r=j,j-&gt;l=i; &#125; &#125; &#125; void delCol(linkList* *a,int m_cols)&#123;//删除列，删除列中为1的所有行 a[m_cols]-&gt;r-&gt;l=a[m_cols]-&gt;l, a[m_cols]-&gt;l-&gt;r=a[m_cols]-&gt;r;//删除列，删除列头就可以保证不被访问 for (linkList *q=a[m_cols]-&gt;d;q!=a[m_cols];q=q-&gt;d) for (linkList* p=q-&gt;r;p!=q;p=p-&gt;r) p-&gt;u-&gt;d=p-&gt;d,p-&gt;d-&gt;u=p-&gt;u;//删除行，需要删除其他列中改行的元素 &#125; void resCol(linkList* *a,int m_cols)&#123; a[m_cols]-&gt;r-&gt;l=a[m_cols]-&gt;l-&gt;r=a[m_cols];//恢复列 for (linkList *q=a[m_cols]-&gt;d;q!=a[m_cols];q=q-&gt;d) for (linkList* p=q-&gt;r;p!=q;p=p-&gt;r) p-&gt;u-&gt;d=p-&gt;d-&gt;u=p;//恢复行，需要恢复其他列中改行的元素 &#125;&#125;using namespace LINKLIST;const int max_n=729+10,max_m=324+10;linkList* a[max_m],*b[max_n];bool flag=false;void dfs()&#123; if (flag==true) return ; if (a[0]-&gt;r==a[0])&#123; flag=true; return ; &#125; linkList *next=a[0]-&gt;r; if (next-&gt;d==next) return ;//代表a[0]-&gt;r这条件无法满足 delCol(a,next-&gt;cols); for (linkList *q=next-&gt;d;q!=next;q=q-&gt;d)&#123;//枚举行 for (linkList *p=q-&gt;r;p!=q;p=p-&gt;r) delCol(a,p-&gt;cols);//删除行对应的列 dfs(); for (linkList *p=q-&gt;r;p!=q;p=p-&gt;r) resCol(a,p-&gt;cols); &#125; resCol(a,next-&gt;cols);&#125;bool nums[max_n][max_m];void sol()&#123; int n,m; n=310,m=724; for (int q=1;q&lt;=n;++q) for (int p=1,i;p&lt;=m;++p)&#123; cin&gt;&gt;i; if (i)&#123; &#125; &#125; inc=0; for (int q=0;q&lt;=n;++q) b[q]=NULL; a[0]=NewMemory(); for (int q=1;q&lt;=m;++q)&#123; a[q]=NewMemory(); a[q]-&gt;l=a[q-1],a[q-1]-&gt;r=a[q]; a[q]-&gt;u=a[q]-&gt;d=a[q]; a[q]-&gt;cols=q; &#125; a[0]-&gt;l=a[m],a[m]-&gt;r=a[0]; for (int q=1,ch;q&lt;=n;++q)&#123; for (int p=1;p&lt;=m;++p)&#123; cin&gt;&gt;ch; if (ch)&#123; linkList* i=NewMemory(); i-&gt;cols=p; append(a[p],i,LINKLIST::up); if (b[q]==NULL)&#123; b[q]=i; b[q]-&gt;l=b[q]-&gt;r=b[q]; &#125; else &#123; append(b[q],i,LINKLIST::right); b[q]=i; &#125; &#125; &#125; &#125; flag=false; dfs(); cout&lt;&lt;(flag?"Yes":"No")&lt;&lt;endl;&#125;int main()&#123; cin.sync_with_stdio(false); cout.sync_with_stdio(false); int t; cin&gt;&gt;t; while (t--)&#123; sol(); &#125; return 0;&#125; #1321 : 搜索五·数独参考跳跃的舞者，舞蹈链（Dancing Links）算法——求解精确覆盖问题]]></content>
      <categories>
        <category>ACM</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>dance link</tag>
        <tag>搜索</tag>
        <tag>双向十字循环链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[康复训练·后缀自动机]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83%C2%B7%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[后缀自动机 (suffix automaton SAM)，有穷状态自动机(deterministic finite automaton,DFA)的一种。 构造1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const int max_n=1e6+10;const int char_size=26;//字符集合大小int slink[2*max_n+10];int tran[2*max_n+10][char_size];int max_len[2*max_n+10],min_len[2*max_n+10];int sam_len=0;int new_state(int _max_len,int _min_len,int *_tran,int _slink)&#123; slink[sam_len]=_slink; if (_tran==NULL) for (int q=0;q&lt;char_size;++q) tran[sam_len][q]=-1; else for (int q=0;q&lt;char_size;++q) tran[sam_len][q]=_tran[q]; max_len[sam_len]=_max_len,min_len[sam_len]=_min_len; return sam_len++;&#125;int add_char(char i,int _now)&#123; int _next=new_state(max_len[_now]+1,0,NULL,-1); int c=i-'a'; while (_now!=-1 &amp;&amp; tran[_now][c]==-1)&#123; tran[_now][c]=_next; _now=slink[_now]; &#125; if (_now==-1)&#123; slink[_next]=0,min_len[_next]=1; return _next; &#125; else &#123; int p= tran[_now][c]; if (max_len[p]==max_len[_now]+1)&#123; min_len[_next]=max_len[p]+1; slink[_next]=p; return _next; &#125; else &#123; int _temp=new_state(max_len[_now]+1,min_len[_now]+1,tran[p],slink[p]); slink[p]=_temp,min_len[p]=max_len[_temp]+1; slink[_next]=_temp,min_len[_next]=max_len[_temp]+1; min_len[_temp]=max_len[slink[_temp]]+1; while (_now!=-1 &amp;&amp; tran[_now][c]==p)&#123; tran[_now][c]=_temp; _now=slink[_now]; &#125; return _next; &#125; &#125;&#125;void SAM(char *s)&#123; sam_len=0; int now=new_state(0,0,NULL,-1); int str_len=strlen(s); for (int q=0;q&lt;str_len;++q)&#123; now=add_char(s[q],now); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Suffix Automaton</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
